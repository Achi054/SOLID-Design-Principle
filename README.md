  # SOLID Design Principle

**SOLID** principles provide us with ways to move from tightly coupled code and little encapsulation to the much desired loosely coupled and encapsulated code. 

`SOLID` is an acronym for the following five principles:
  - [_Single Responsibility Principle (SRP)_<br>](#single-responsibility-principle-srp)
  - [_Open/Closed Principle_<br>](#openclosed-principle)
  - [_Liskov Substitution Principle_<br>](#liskov-substitution-principle)
  - [_Interface Segregation Principle_<br>](#interface-segregation-principle)
  - [_Dependency Inversion Principle_<br>](#dependency-inversion-principle)

<a name="single-responsibility-principle-srp"></a>
## _Single Responsibility Principle (SRP)_<br>
Every software module, class, struct or functions should have one responsibility.

<a name="openclosed-principle"></a>
## _Open/Closed Principle_<br>
Every software module, classes, methods, function etc. are open for extension, but closed for modification.

<a name="liskov-substitution-principle"></a>
## _Liskov Substitution Principle_<br>
If super/derived/child class inherits from base/parent class, then all the instance of the super/derived/child class should be able to replace base/parent class.

<a name="interface-segregation-principle"></a>
## _Interface Segregation Principle_<br>
client(s) should not be forced to implement interfaces they donâ€™t use.

<a name="dependency-inversion-principle"></a>
## _Dependency Inversion Principle_<br>
High-level class must not depend upon a low level class. They must both depend upon abstraction. Abstraction must not depend on details, rather the details must depend upon abstractions.


  

